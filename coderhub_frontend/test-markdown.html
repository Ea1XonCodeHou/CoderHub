<!DOCTYPE html>
<html>
<head>
  <title>Markdown 渲染测试</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      max-width: 800px;
      margin: 40px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .message-text {
      background: white;
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .markdown-heading {
      font-weight: 600;
      line-height: 1.3;
      margin-top: 24px;
      margin-bottom: 16px;
      color: #1f2937;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 8px;
    }
    .markdown-h1 { font-size: 1.875rem; margin-top: 0; }
    .markdown-h2 { font-size: 1.5rem; }
    .markdown-h3 { font-size: 1.25rem; border-bottom: none; }
    .markdown-paragraph { margin-bottom: 16px; line-height: 1.75; }
    .markdown-list { margin-bottom: 16px; padding-left: 28px; }
    .markdown-list-item { margin-bottom: 8px; line-height: 1.6; }
    code:not(.hljs) {
      background: #f3f4f6;
      padding: 2px 8px;
      border-radius: 4px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.875em;
      color: #d63384;
      border: 1px solid #e5e7eb;
    }
    pre {
      background: #282c34;
      padding: 16px;
      border-radius: 8px;
      overflow-x: auto;
      margin: 16px 0;
    }
    pre code.hljs {
      background: transparent;
      padding: 0;
      color: #abb2bf;
      font-size: 14px;
      line-height: 1.6;
    }
  </style>
</head>
<body>
  <h1>Markdown 渲染测试</h1>
  <div class="message-text" id="output"></div>

  <script>
    // 配置自定义渲染器
    const renderer = new marked.Renderer();

    renderer.code = function(code, language) {
      const validLanguage = language && hljs.getLanguage(language) ? language : 'plaintext';
      const highlighted = hljs.highlight(code, { language: validLanguage }).value;
      return `<pre><code class="hljs language-${validLanguage}">${highlighted}</code></pre>`;
    };

    renderer.heading = function(text, level) {
      return `<h${level} class="markdown-heading markdown-h${level}">${text}</h${level}>`;
    };

    renderer.paragraph = function(text) {
      return `<p class="markdown-paragraph">${text}</p>`;
    };

    renderer.list = function(body, ordered) {
      const type = ordered ? 'ol' : 'ul';
      return `<${type} class="markdown-list">${body}</${type}>`;
    };

    renderer.listitem = function(text) {
      return `<li class="markdown-list-item">${text}</li>`;
    };

    marked.setOptions({
      renderer: renderer,
      breaks: true,
      gfm: true,
      headerIds: false,
      mangle: false
    });

    // 测试内容
    const testMarkdown = `Vue 3 的 Composition API 是 Vue 3 引入的一个革命性新特性...

## ? 1. 逻辑复用更简单、更灵活

### 问题：Options API 中逻辑复用困难

在 Options API 中，组件逻辑分散在 data、methods、computed、watch、生命周期钩子中。

### 解决：Composition API 使用组合函数（Composables）

通过 setup() + 组合函数，你可以将逻辑封装成可复用的函数，例如：

\`\`\`javascript
// useUser.js
import { ref, onMounted } from 'vue'

export function useUser() {
  const user = ref(null)
  const fetchUser = async () => {
    user.value = await api.getUser()
  }
  onMounted(fetchUser)
  return { user, fetchUser }
}
\`\`\`

在组件中直接调用：

\`\`\`vue
<script setup>
import { useUser } from './useUser'
const { user, fetchUser } = useUser()
</script>
\`\`\`

? **优势**：
- 无命名冲突
- 逻辑清晰
- 可复用
- 可测试

---

## ? 2. 更好的 TypeScript 支持

Composition API 基于函数和显式返回值，类型推导更自然：

\`\`\`typescript
import { ref } from 'vue'

const count = ref(0) // 类型自动推导为 Ref<number>
count.value = 1 // ? 类型检查通过
count.value = 'a' // ? 类型错误
\`\`\`
`;

    // 渲染
    document.getElementById('output').innerHTML = marked(testMarkdown);
  </script>
</body>
</html>
